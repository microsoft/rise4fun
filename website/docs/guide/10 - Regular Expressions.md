---
title: Regular Expressions
sidebar_position: 10
---

The sort constructor <tt>RegEx</tt> takes as argument a sequence type.
The set of regular expressions over strings is thus <tt>(RegEx String)</tt>.

# Operations

<table>
  <tr>
    <td>Operation</td>
    <td>Brief description</td>
  </tr>
  <tr> 
    <td><tt>(str.to.re s)</tt></td>
    <td>Convert string to regular expression accepting <tt>s</tt>.</td>
  </tr>
  <tr> 
    <td><tt>(str.in.re s r)</tt></td>
    <td>Determine if <tt>s</tt> is in the language generated by <tt>r</tt>.</td>
  </tr>
  <tr> 
    <td><tt>re.allchar</tt></td>
    <td>The regular expression accepting every string.</td>
  </tr>
  <tr> 
    <td><tt>re.nostr</tt></td>
    <td>The regular expression rejecting every string.</td>
  </tr>
  <tr> 
    <td><tt>(re.range ch1 ch2)</tt></td>
    <td>The range of characters between <tt>ch1</tt> and <tt>ch2</tt>.</td>
  </tr>
  <tr> 
    <td><tt>(re.++ r1 r2 r3)</tt></td>
    <td>Concatenation of regular expressions.</td>
  </tr>
  <tr> 
    <td><tt>(re.* r)</tt></td>
    <td>Kleene star.</td>
  </tr>
  <tr> 
    <td><tt>(re.+ r)</tt></td>
    <td>Kleene plus.</td>
  </tr>
  <tr> 
    <td><tt>(re.opt r)</tt></td>
    <td>Zero or one use of <tt>r</tt>.</td>
  </tr>
  <tr> 
    <td><tt>((_ re.loop lo hi) r)</tt></td>
    <td>from <tt>lo</tt> to <tt>hi</tt> number of repetitions of <tt>r</tt>.</td>
  </tr>  
  <tr> 
    <td><tt>(re.union r1 r2)</tt></td>
    <td>The union of regular languages.</td>
  </tr>
  <tr> 
    <td><tt>(re.inter r1 r2)</tt></td>
    <td>The intersection of regular languages. </td>
  </tr>

  <tr> 
    <td><tt>(seq.to.re s)</tt></td>
    <td>Convert sequenceto regular expression accepting <tt>s</tt>.</td>
  </tr>
  <tr> 
    <td><tt>(seq.in.re s r)</tt></td>
    <td>Determine if sequence <tt>s</tt> is in the language generated by <tt>r</tt>.</td>
  </tr>
  <tr> 
    <td><tt>(as re.all R)</tt></td>
    <td>The regular expression of sort <tt>R</tt> accepting every sequence.</td>
  </tr>
  <tr> 
    <td><tt>(as re.empty R)</tt></td>
    <td>The regular expression of sort <tt>R</tt> rejecting every sequence.</td>
  </tr>


</table>

The <tt>re.range</tt> operator expects two strings each encoding a single character.
For example <tt>(str.range "a" "\xff")</tt> is a valid range of characters, 
while <tt>(str.range "aa" "")</tt> is not associated with any specified range. 


For added compatibility with CVC4's format, 
Z3 also accepts expressions of the form <tt>(re.loop r lo hi)</tt>.
Z3 understands only the meaning of these terms when <tt>lo, hi</tt> are 
integer numerals.

# What (not) to expect of regular expressions
Z3 converts regular expressions into non-deterministic finite automata and 
expands membership constraints over symbolic strings and sequences 
when it tries to satisfy constraints. This approach works for many
membership and non-membership constraints, but is not a complete 
procedure (and even less complete when there are other constraints 
on the symbolic strings).
It also does not handle regular expressions symbolic sequences (it allows
to express non-regular languages).
Thus, the string <tt>s</tt> in <tt>(str.to.re s)</tt> should be 
a string literal. You can write formulas with equalities over 
regular expressions, but chances are that Z3 will not do anything 
profound with them. Therefore, for now, use regular expressions only in
constraints of the form <tt>(str.in.re s r)</tt>.

# Examples

The maximal length is 6 for a string of length 2 repeated at most 3 times.

```z3
(declare-const a String)
(push)
(set-info :status sat)
(assert (str.in.re a ((_ re.loop 1 3) (str.to.re "ab"))))
(assert (= (str.len a) 6))
(check-sat)
(get-model)
(pop)

(push)
(set-info :status unsat)
(assert (str.in.re a ((_ re.loop 1 3) (str.to.re "ab"))))
(assert (> (str.len a) 6))
(check-sat)
(pop)
```
 
